#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : require

#define RAY_TRACING
#include "common.glsl"
#include "scene_descriptor_set.glsl"

// ------------------------------------------------------------------------
// DEFINES ----------------------------------------------------------------
// ------------------------------------------------------------------------

#define G_BUFFER_MIP 1
#define MAX_ROUGHNESS 0.8f

// ------------------------------------------------------------------------
// DESCRIPTOR SETS --------------------------------------------------------
// ------------------------------------------------------------------------

layout(set = 1, binding = 0, rgba16f) uniform image2D i_Color;
layout(set = 1, binding = 1, r16f) uniform image2D i_HitDistance;

layout(set = 2, binding = 0) uniform PerFrameUBO
{
    mat4  view_inverse;
    mat4  proj_inverse;
    mat4  view_proj_inverse;
    mat4  prev_view_proj;
    mat4  view_proj;
    vec4  cam_pos;
    Light light;
}
ubo;

layout(set = 2, binding = 1) uniform sampler2D s_BlueNoise1;

layout(set = 3, binding = 0) uniform sampler2D s_GBuffer1; // RGB: Albedo, A: Roughness
layout(set = 3, binding = 1) uniform sampler2D s_GBuffer2; // RGB: Normal, A: Metallic
layout(set = 3, binding = 2) uniform sampler2D s_GBuffer3; // RG: Motion Vector, BA: -
layout(set = 3, binding = 3) uniform sampler2D s_GBufferDepth;

// ------------------------------------------------------------------------
// PUSH CONSTANTS ---------------------------------------------------------
// ------------------------------------------------------------------------

layout(push_constant) uniform PushConstants
{
    uint num_frames;
    float bias;
}
u_PushConstants;

// ------------------------------------------------------------------------
// PAYLOADS ---------------------------------------------------------------
// ------------------------------------------------------------------------

layout(location = 0) rayPayloadEXT ReflectionPayload p_PathTracePayload;

// ------------------------------------------------------------------------
// FUNCTIONS --------------------------------------------------------------
// ------------------------------------------------------------------------

mat3 create_tbn(vec3 N) 
{
    vec3 U;
    if (abs(N.z) > 0.0) 
    {
        float k = sqrt(N.y * N.y + N.z * N.z);
        U.x = 0.0; U.y = -N.z / k; U.z = N.y / k;
    }
    else 
    {
        float k = sqrt(N.x * N.x + N.y * N.y);
        U.x = N.y / k; U.y = -N.x / k; U.z = 0.0;
    }
    
    mat3 TBN;
    TBN[0] = U;
    TBN[1] = cross(N, U);
    TBN[2] = N;
    return transpose(TBN);
}

// ------------------------------------------------------------------------

// Input Ve: view direction
// Input alpha_x, alpha_y: roughness parameters
// Input U1, U2: uniform random numbers
// Output Ne: normal sampled with PDF D_Ve(Ne) = G1(Ve) * max(0, dot(Ve, Ne)) * D(Ne) / Ve.z
vec3 sample_ggx_vndf(vec3 Ve, float alpha_x, float alpha_y, float U1, float U2)
{
    // Section 3.2: transforming the view direction to the hemisphere configuration
    vec3 Vh = normalize(vec3(alpha_x * Ve.x, alpha_y * Ve.y, Ve.z));
    // Section 4.1: orthonormal basis (with special case if cross product is zero)
    float lensq = Vh.x * Vh.x + Vh.y * Vh.y;
    vec3 T1 = lensq > 0 ? vec3(-Vh.y, Vh.x, 0) * inversesqrt(lensq) : vec3(1,0,0);
    vec3 T2 = cross(Vh, T1);
    // Section 4.2: parameterization of the projected area
    float r = sqrt(U1);
    float phi = 2.0 * M_PI * U2;
    float t1 = r * cos(phi);
    float t2 = r * sin(phi);
    float s = 0.5 * (1.0 + Vh.z);
    t2 = (1.0 - s) * sqrt(1.0 - t1*t1) + s*t2;
    // Section 4.3: reprojection onto hemisphere
    vec3 Nh = t1*T1 + t2*T2 + sqrt(max(0.0f, 1.0f - t1*t1 - t2*t2))*Vh;
    // Section 3.4: transforming the normal back to the ellipsoid configuration
    vec3 Ne = normalize(vec3(alpha_x * Nh.x, alpha_y * Nh.y, max(0.0, Nh.z)));
    return Ne;
}

// ------------------------------------------------------------------------

vec3 world_position_from_depth(vec2 tex_coords, float ndc_depth)
{
    // Take texture coordinate and remap to [-1.0, 1.0] range.
    vec2 screen_pos = tex_coords * 2.0 - 1.0;

    // // Create NDC position.
    vec4 ndc_pos = vec4(screen_pos, ndc_depth, 1.0);

    // Transform back into world position.
    vec4 world_pos = ubo.view_proj_inverse * ndc_pos;

    // Undo projection.
    world_pos = world_pos / world_pos.w;

    return world_pos.xyz;
}

// ------------------------------------------------------------------------
// MAIN -------------------------------------------------------------------
// ------------------------------------------------------------------------

void main()
{
    p_PathTracePayload.rng = rng_init(gl_LaunchIDEXT.xy, u_PushConstants.num_frames);

    const ivec2 size          = textureSize(s_GBuffer1, G_BUFFER_MIP);
    const ivec2 current_coord = ivec2(gl_LaunchIDEXT.xy);
    const vec2  pixel_center  = vec2(current_coord) + vec2(0.5);
    const vec2  tex_coord     = pixel_center / vec2(size);

    float depth = texelFetch(s_GBufferDepth, current_coord, G_BUFFER_MIP).r;

    if (depth == 1.0f)
    {
        imageStore(i_Color, current_coord, vec4(0.0f, 0.0f, 0.0f, -1.0f));
        return;
    }

    float roughness = texelFetch(s_GBuffer1, current_coord, G_BUFFER_MIP).a;
    roughness = roughness * roughness;
    roughness = min(roughness, MAX_ROUGHNESS);
    
    vec3  P         = world_position_from_depth(tex_coord, depth);
    vec3  N         = texelFetch(s_GBuffer2, current_coord, G_BUFFER_MIP).rgb;
    vec3  V        = normalize(ubo.cam_pos.xyz - P.xyz);

    uint  ray_flags  = gl_RayFlagsOpaqueEXT;
    uint  cull_mask  = 0xff;
    float tmin       = 0.001;
    float tmax       = 10000.0;
    vec3  ray_origin = P + N * u_PushConstants.bias;

    p_PathTracePayload.ray_length = 0.0f;

    mat3 basis = create_tbn(N);
    vec3 tangent_V = basis * V;
    vec3 tangent_H = sample_ggx_vndf(tangent_V, roughness, roughness, 0.0f, 0.0f);
    vec3 H = normalize(inverse(basis) * tangent_H);

    vec3 R = normalize(reflect(-V, H));

    traceRayEXT(u_TopLevelAS, ray_flags, cull_mask, 0, 0, 0, ray_origin, tmin, R, tmax, 0);

    imageStore(i_Color, current_coord, vec4(p_PathTracePayload.color, 1.0f));
    imageStore(i_HitDistance, current_coord, vec4(p_PathTracePayload.ray_length));
}

// ------------------------------------------------------------------------
