#version 450

#extension GL_GOOGLE_include_directive : require

#include "common.glsl"

// ------------------------------------------------------------------
// DEFINES ----------------------------------------------------------
// ------------------------------------------------------------------

#define NUM_THREADS_X 32
#define NUM_THREADS_Y 32
#define DEPTH_FACTOR 0.5
#define MAX_ROUGHNESS 0.8f
#define G_BUFFER_MIP 1
#define FILTER_WIDTH 4
#define MAX_REFLECTION_MIP 7.0f

// ------------------------------------------------------------------
// INPUTS -----------------------------------------------------------
// ------------------------------------------------------------------

layout(local_size_x = NUM_THREADS_X, local_size_y = NUM_THREADS_Y, local_size_z = 1) in;

// ------------------------------------------------------------------
// DESCRIPTOR SETS --------------------------------------------------
// ------------------------------------------------------------------

layout(set = 0, binding = 0, rgba16f) uniform image2D i_Output;

layout(set = 1, binding = 0) uniform sampler2D s_Radiance;
layout(set = 1, binding = 1) uniform sampler2D s_HitDistance;

layout(set = 2, binding = 0) uniform sampler2D s_GBuffer1; // RGB: Albedo, A: Roughness
layout(set = 2, binding = 1) uniform sampler2D s_GBuffer2; // RGB: Normal, A: Metallic
layout(set = 2, binding = 2) uniform sampler2D s_GBuffer3; // RG: Motion Vector, BA: -
layout(set = 2, binding = 3) uniform sampler2D s_GBufferDepth;

layout(set = 3, binding = 0) uniform PerFrameUBO
{
    mat4  view_inverse;
    mat4  proj_inverse;
    mat4  view_proj_inverse;
    mat4  prev_view_proj;
    mat4  view_proj;
    vec4  cam_pos;
    Light light;
}
ubo;

// ------------------------------------------------------------------------
// PUSH CONSTANTS ---------------------------------------------------------
// ------------------------------------------------------------------------

layout(push_constant) uniform PushConstants
{
    vec4  z_buffer_params;
    float p;
    uint debug_mip_level;
}
u_PushConstants;

// ------------------------------------------------------------------
// CONSTANTS --------------------------------------------------------
// ------------------------------------------------------------------

const ivec2 g_offsets[15] = ivec2[](
    ivec2(-1, -1),
    ivec2(0, -1),
    ivec2(1, -1),
    ivec2(2, -1),
    ivec2(-1, 0),
    ivec2(1, 0),
    ivec2(2, 0),
    ivec2(-1, 1),
    ivec2(0, 1),
    ivec2(1, 1),
    ivec2(2, 1),
    ivec2(-1, 2),
    ivec2(0, 2),
    ivec2(1, 2),
    ivec2(2, 2));

// ------------------------------------------------------------------
// FUNCTIONS --------------------------------------------------------
// ------------------------------------------------------------------

float linear_eye_depth(float z)
{
    return 1.0 / (u_PushConstants.z_buffer_params.z * z + u_PushConstants.z_buffer_params.w);
}

// ------------------------------------------------------------------------

float normal_edge_stopping_weight(vec3 center_normal, vec3 sample_normal)
{
    return pow(abs(dot(center_normal, sample_normal)), 32);
}

// ------------------------------------------------------------------------

float depth_edge_stopping_weight(float center_lin_depth, float sample_lin_depth)
{
    float depth_diff = abs(center_lin_depth - sample_lin_depth);
    float d_factor   = depth_diff * DEPTH_FACTOR;
    return exp(-(d_factor * d_factor));
}

// ------------------------------------------------------------------------

mat3 create_tbn(vec3 N)
{
    vec3 U;
    if (abs(N.z) > 0.0)
    {
        float k = sqrt(N.y * N.y + N.z * N.z);
        U.x     = 0.0;
        U.y     = -N.z / k;
        U.z     = N.y / k;
    }
    else
    {
        float k = sqrt(N.x * N.x + N.y * N.y);
        U.x     = N.y / k;
        U.y     = -N.x / k;
        U.z     = 0.0;
    }

    mat3 TBN;
    TBN[0] = U;
    TBN[1] = cross(N, U);
    TBN[2] = N;
    return transpose(TBN);
}

// ------------------------------------------------------------------------

// Input Ve: view direction
// Input alpha_x, alpha_y: roughness parameters
// Input U1, U2: uniform random numbers
// Output Ne: normal sampled with PDF D_Ve(Ne) = G1(Ve) * max(0, dot(Ve, Ne)) * D(Ne) / Ve.z
vec3 sample_ggx_vndf(vec3 Ve, float alpha_x, float alpha_y, float U1, float U2)
{
    // Section 3.2: transforming the view direction to the hemisphere configuration
    vec3 Vh = normalize(vec3(alpha_x * Ve.x, alpha_y * Ve.y, Ve.z));
    // Section 4.1: orthonormal basis (with special case if cross product is zero)
    float lensq = Vh.x * Vh.x + Vh.y * Vh.y;
    vec3  T1    = lensq > 0 ? vec3(-Vh.y, Vh.x, 0) * inversesqrt(lensq) : vec3(1, 0, 0);
    vec3  T2    = cross(Vh, T1);
    // Section 4.2: parameterization of the projected area
    float r   = sqrt(U1);
    float phi = 2.0 * M_PI * U2;
    float t1  = r * cos(phi);
    float t2  = r * sin(phi);
    float s   = 0.5 * (1.0 + Vh.z);
    t2        = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;
    // Section 4.3: reprojection onto hemisphere
    vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0f, 1.0f - t1 * t1 - t2 * t2)) * Vh;
    // Section 3.4: transforming the normal back to the ellipsoid configuration
    vec3 Ne = normalize(vec3(alpha_x * Nh.x, alpha_y * Nh.y, max(0.0, Nh.z)));
    return Ne;
}

// ------------------------------------------------------------------

vec3 bilateral_blur(vec2 tex_coord, int mip_level)
{
    const int   g_buffer_mip = mip_level + 1;
    const ivec2 size         = textureSize(s_Radiance, mip_level);
    const vec2  inv_size     = vec2(1.0f / size.x, 1.0f / size.y);

    // Load the center sample depth and normal
    float center_depth  = linear_eye_depth(textureLod(s_GBufferDepth, tex_coord, g_buffer_mip).r);
    vec3  center_normal = textureLod(s_GBuffer2, tex_coord, g_buffer_mip).rgb;

    vec3  total_color  = textureLod(s_Radiance, tex_coord, mip_level).rgb;
    float total_weight = 1.0f;

    for (int i = 0; i < 15; i++)
    {
        // Remap the poisson sample to [-1.0, +1.0] range
        vec2 offset = vec2(g_offsets[i]);

        // Generate sample coordinate
        vec2 sample_tex_coord = tex_coord + (offset * inv_size);

        // Load cross bilateral samples
        vec3  sample_color  = textureLod(s_Radiance, sample_tex_coord, mip_level).rgb;
        float sample_depth  = linear_eye_depth(textureLod(s_GBufferDepth, sample_tex_coord, g_buffer_mip).r);
        vec3  sample_normal = textureLod(s_GBuffer2, sample_tex_coord, g_buffer_mip).rgb;

        // Compute edge-stopping weights
        float weight = depth_edge_stopping_weight(center_depth, sample_depth) * normal_edge_stopping_weight(center_normal, sample_normal);

        // Accumulate samples and weights
        total_color += weight * sample_color;
        total_weight += weight;
    }

    // Divide by total weight
    return total_color / total_weight;
}

// ------------------------------------------------------------------

vec3 lobe_direction(float p, float roughness, vec3 V, vec3 tangent_V, mat3 basis, mat3 inv_basis)
{
    vec3 tangent_H = sample_ggx_vndf(tangent_V, roughness, roughness, p, 0.0f);
    vec3 H         = normalize(inv_basis * tangent_H);

    return normalize(reflect(-V, H));
}

// ------------------------------------------------------------------------

vec3 reflected_point(vec3 hit_point, vec3 plane_point, vec3 plane_normal)
{
    vec3  v = hit_point - plane_point;
    float d = dot(v, plane_normal);
    return hit_point - plane_normal * 2.0f * d;
}

// ------------------------------------------------------------------

float reflection_mip_level(float hit_distance, vec3 frag_pos, vec3 N, vec3 dominant_dir, vec3 side_dir, ivec2 size)
{
    float cos_beta        = dot(dominant_dir, side_dir);
    float angle           = acos(cos_beta);
    float side_dir_length = hit_distance / cos_beta;

    vec3 dominant_hit_pos = frag_pos + dominant_dir * hit_distance;
    vec3 side_hit_pos     = frag_pos + side_dir * side_dir_length;
    vec3 right_dir        = normalize(side_hit_pos - dominant_hit_pos);
    vec3 up_dir           = cross(-dominant_dir, right_dir);

    float quad_extent = tan(angle) * hit_distance;

    vec3 min_extents = dominant_hit_pos + up_dir * quad_extent - right_dir * quad_extent; // Top Left
    vec3 max_extents = dominant_hit_pos - up_dir * quad_extent + right_dir * quad_extent; // Bottom Right

    vec3 refl_min_extents = reflected_point(min_extents, frag_pos, N);
    vec3 refl_max_extents = reflected_point(max_extents, frag_pos, N);

    vec4 p_max_extents = ubo.view_proj * vec4(refl_max_extents, 1.0f);
    vec4 p_min_extents = ubo.view_proj * vec4(refl_min_extents, 1.0f);

    p_max_extents.xy /= p_max_extents.w;
    p_min_extents.xy /= p_min_extents.w;

    p_max_extents.xy = p_max_extents.xy * 0.5f + 0.5f;
    p_min_extents.xy = p_min_extents.xy * 0.5f + 0.5f;

    vec2 sc_max_extents = p_max_extents.xy * vec2(size);
    vec2 sc_min_extents = p_min_extents.xy * vec2(size);

    return min(log2(length(sc_max_extents - sc_min_extents) / FILTER_WIDTH), MAX_REFLECTION_MIP);
}

// ------------------------------------------------------------------------

vec3 world_position_from_depth(vec2 tex_coords, float ndc_depth)
{
    // Take texture coordinate and remap to [-1.0, 1.0] range.
    vec2 screen_pos = tex_coords * 2.0 - 1.0;

    // // Create NDC position.
    vec4 ndc_pos = vec4(screen_pos, ndc_depth, 1.0);

    // Transform back into world position.
    vec4 world_pos = ubo.view_proj_inverse * ndc_pos;

    // Undo projection.
    world_pos = world_pos / world_pos.w;

    return world_pos.xyz;
}

// ------------------------------------------------------------------
// MAIN -------------------------------------------------------------
// ------------------------------------------------------------------

void main()
{
    // Query the G-Buffer image size
    const ivec2 size = textureSize(s_GBuffer1, G_BUFFER_MIP);

    // Compute current pixel coord
    const ivec2 current_coord = ivec2(gl_GlobalInvocationID.xy);
    const vec2  pixel_center  = vec2(current_coord) + vec2(0.5);
    const vec2  tex_coord     = pixel_center / vec2(size);

    // Skip pixel if it belongs to the background
    float depth = texelFetch(s_GBufferDepth, current_coord, G_BUFFER_MIP).r;

    if (depth == 1.0f)
    {
        imageStore(i_Output, current_coord, vec4(0.0f));
        return;
    }

    float roughness = texelFetch(s_GBuffer1, current_coord, G_BUFFER_MIP).a;
    roughness       = roughness * roughness;
    roughness       = min(roughness, MAX_ROUGHNESS);

    float hit_distance = texelFetch(s_HitDistance, current_coord, 0).r;

    if (hit_distance == -1.0f)
    {
        vec3 radiance = u_PushConstants.debug_mip_level == 1 ? vec3(0.0f) : texelFetch(s_Radiance, current_coord, 0).rgb;
        imageStore(i_Output, current_coord, vec4(radiance, 1.0f));
        return;
    }

    vec3 P = world_position_from_depth(tex_coord, depth);
    vec3 N = texelFetch(s_GBuffer2, current_coord, G_BUFFER_MIP).rgb;
    vec3 V = normalize(ubo.cam_pos.xyz - P.xyz);

    // Compute basis
    mat3 basis     = create_tbn(N);
    mat3 inv_basis = transpose(basis);
    vec3 tangent_V = basis * V;

    // Compute Dominant and Side directions for determining BRDF Lobe Quad
    vec3 dominant_dir = lobe_direction(0.0f, roughness, V, tangent_V, basis, inv_basis);
    vec3 side_dir     = lobe_direction(u_PushConstants.p, roughness, V, tangent_V, basis, inv_basis);

    // Compute mip level
    float mip_level = reflection_mip_level(hit_distance, P, N, dominant_dir, side_dir, size);
    int   high_mip  = int(ceil(mip_level));
    int   low_mip   = int(floor(mip_level));

    // Sample radiance with 4x4 bilateral blur
    vec3 high_blur = bilateral_blur(tex_coord, high_mip);
    vec3 low_blur  = bilateral_blur(tex_coord, low_mip);

    // Blend mip samples
    float blend             = mip_level - float(low_mip);
    vec3  resolved_radiance = u_PushConstants.debug_mip_level == 1 ? vec3(mip_level) : mix(low_blur, high_blur, blend);

    // Store blurred ao
    imageStore(i_Output, current_coord, vec4(resolved_radiance, 1.0f));
}

// ------------------------------------------------------------------