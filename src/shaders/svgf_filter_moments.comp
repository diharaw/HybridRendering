#version 450

// ------------------------------------------------------------------
// DEFINES ----------------------------------------------------------
// ------------------------------------------------------------------

#define NUM_THREADS 32

// ------------------------------------------------------------------
// INPUTS -----------------------------------------------------------
// ------------------------------------------------------------------

layout(local_size_x = NUM_THREADS, local_size_y = NUM_THREADS, local_size_z = 1) in;

// ------------------------------------------------------------------
// DESCRIPTOR SETS --------------------------------------------------
// ------------------------------------------------------------------

layout(set = 0, binding = 0, rgba16f) uniform image2D i_Color;

layout(set = 1, binding = 0) uniform sampler2D s_LinearZ;
layout(set = 1, binding = 1) uniform sampler2D s_Normals;
layout(set = 1, binding = 2) uniform sampler2D s_Moments;
layout(set = 1, binding = 3) uniform sampler2D s_HistoryLength;

// ------------------------------------------------------------------
// PUSH CONSTANTS ---------------------------------------------------
// ------------------------------------------------------------------

layout(push_constant) uniform PushConstants
{
    float phi_color;
    float phi_normal;
}
u_PushConstants;

// ------------------------------------------------------------------
// FUNCTIONS --------------------------------------------------------
// ------------------------------------------------------------------

vec3 octohedral_to_direction(uint octo)
{
    vec2 e = unpackSnorm2x16(octo);
    vec3 v = vec3(e, 1.0 - abs(e.x) - abs(e.y));
    if (v.z < 0.0)
        v.xy = (1.0 - abs(v.yx)) * (step(0.0, v.xy) * 2.0 - vec2(1.0));
    return normalize(v);
}

// ------------------------------------------------------------------

float luminance(vec3 rgb)
{
    return dot(rgb, vec3(0.2126f, 0.7152f, 0.0722f));
}

// ------------------------------------------------------------------

float normal_distance_cos(vec3 n1, vec3 n2, float power)
{
    //return pow(max(0.0, dot(n1, n2)), 128.0);
    //return pow( saturate(dot(n1,n2)), power);
    return 1.0f;
}

// ------------------------------------------------------------------

float compute_weight(
    float depthCenter, float depthP, float phiDepth, vec3 normalCenter, vec3 normalP, float normPower, float luminanceCenter, float luminanceP, float phi)
{
    const float wNormal = normal_distance_cos(normalCenter, normalP, normPower);
    const float wZ      = (phiDepth == 0) ? 0.0f : abs(depthCenter - depthP) / phiDepth;
    const float wL      = abs(luminanceCenter - luminanceP) / phi;

    const float w = exp(0.0 - max(wL, 0.0) - max(wZ, 0.0)) * wNormal;

    return w;
}

// ------------------------------------------------------------------
// MAIN -------------------------------------------------------------
// ------------------------------------------------------------------

void main()
{
    ivec2 size      = textureSize(s_Normals, 0);
    vec2  tex_coord = vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y) / vec2(size);

    vec4        out_color;
    const ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);

    float h = texelFetch(s_HistoryLength, ipos, 0).r;

    if (h < 4.0) // not enough temporal history available
    {
        float sumWColor  = 0.0;
        vec3  sumColor   = vec3(0.0f);
        vec2  sumMoments = vec2(0.0f);

        const vec4  colorCenter  = imageLoad(i_Color, ipos);
        const float lColorCenter = luminance(colorCenter.rgb);

        vec3 normalCenter = texelFetch(s_Normals, ipos, 0).rgb;
        vec2 zCenter      = texelFetch(s_LinearZ, ipos, 0).rg;

        if (zCenter.x < 0)
        {
            // current pixel does not a valid depth => must be envmap => do nothing
            return;
        }

        const float phiLColor = u_PushConstants.phi_color;
        const float phiDepth  = max(zCenter.y, 1e-8) * 3.0;

        // compute first and second moment spatially. This code also applies cross-bilateral
        // filtering on the input color samples
        const int radius = 3;

        for (int yy = -radius; yy <= radius; yy++)
        {
            for (int xx = -radius; xx <= radius; xx++)
            {
                const ivec2 p         = ipos + ivec2(xx, yy);
                const bool  inside    = all(greaterThanEqual(p, ivec2(0, 0))) && all(lessThan(p, size));
                const bool  samePixel = (xx == 0) && (yy == 0);
                const float kernel    = 1.0;

                if (inside)
                {
                    const vec3 colorP   = imageLoad(i_Color, p).rgb;
                    const vec2 momentsP = texelFetch(s_Moments, p, 0).rg;

                    const float lColorP = luminance(colorP.rgb);

                    vec3 normalP = texelFetch(s_Normals, p, 0).rgb;
                    vec2 zP      = texelFetch(s_LinearZ, p, 0).rg;

                    const float w = compute_weight(
                        zCenter.x, zP.x, phiDepth * length(vec2(xx, yy)), normalCenter, normalP, u_PushConstants.phi_normal, lColorCenter, lColorP, phiLColor);

                    const float wColor = w;

                    sumWColor += wColor;
                    sumColor += colorP * wColor;

                    sumMoments += momentsP * vec2(wColor.xx);
                }
            }
        }

        // Clamp sums to >0 to avoid NaNs.
        sumWColor = max(sumWColor, 1e-6f);

        sumColor /= sumWColor;
        sumMoments /= vec2(sumWColor.xx);

        // compute variance for direct and indirect illumination using first and second moments
        float variance = sumMoments.g - sumMoments.r * sumMoments.r;

        // give the variance a boost for the first frames
        variance *= 4.0 / h;

        out_color = vec4(sumColor, variance);
        imageStore(i_Color, ipos, out_color);
    }
}

// ------------------------------------------------------------------