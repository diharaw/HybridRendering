#version 450

#extension GL_GOOGLE_include_directive : require

#include "common.glsl"

// ------------------------------------------------------------------
// DEFINES ----------------------------------------------------------
// ------------------------------------------------------------------

#define NUM_THREADS 32
#define GLOSSY_ROUGHNESS_THRESHOLD 0.05f
#define EPSILON 0.0001f

// ------------------------------------------------------------------
// INPUTS -----------------------------------------------------------
// ------------------------------------------------------------------

layout(local_size_x = NUM_THREADS, local_size_y = NUM_THREADS, local_size_z = 1) in;

// ------------------------------------------------------------------
// DESCRIPTOR SETS --------------------------------------------------
// ------------------------------------------------------------------

layout(set = 0, binding = 0, rgba16f) uniform image2D i_ReprojectedColor;

layout(set = 1, binding = 0) uniform sampler2D s_Color;
layout(set = 2, binding = 0) uniform sampler2D s_PrevColor;
layout(set = 3, binding = 1) uniform sampler2D s_Hit;

layout(set = 4, binding = 0) uniform sampler2D s_GBuffer1; // RGB: Albedo, A: Roughness
layout(set = 4, binding = 1) uniform sampler2D s_GBuffer2; // RGB: Normal, A: Metallic
layout(set = 4, binding = 2) uniform sampler2D s_GBuffer3; // RG: Motion Vector, BA: -
layout(set = 4, binding = 3) uniform sampler2D s_GBufferDepth;

layout(set = 5, binding = 0) uniform PerFrameUBO
{
    mat4  view_inverse;
    mat4  proj_inverse;
    mat4  view_proj_inverse;
    mat4  prev_view_proj;
    mat4  view_proj;
    vec4  cam_pos;
    Light light;
}
ubo;

// ------------------------------------------------------------------------
// PUSH CONSTANTS ---------------------------------------------------------
// ------------------------------------------------------------------------

layout(push_constant) uniform PushConstants
{
    uint  first_frame;
    float alpha;
}
u_PushConstants;

// ------------------------------------------------------------------
// FUNCTIONS --------------------------------------------------------
// ------------------------------------------------------------------

ivec2 surface_point_reprojection(ivec2 coord, vec2 motion_vector, ivec2 size)
{
    return coord + ivec2(motion_vector * vec2(size));
}

// ------------------------------------------------------------------

ivec2 hit_point_reprojection(vec3 ray_origin, float ray_length, ivec2 size)
{
    vec3 camera_ray = ray_origin - ubo.cam_pos.xyz;
        
    float camera_ray_length = length(camera_ray);
    float reflection_ray_length = ray_length;

    camera_ray = normalize(camera_ray);

    vec3 parallax_hit_point = ubo.cam_pos.xyz + camera_ray * (camera_ray_length + reflection_ray_length);

    vec4 reprojected_parallax_hit_point = ubo.prev_view_proj * vec4(parallax_hit_point, 1.0f);

    reprojected_parallax_hit_point.xy /= reprojected_parallax_hit_point.w;

    return ivec2((reprojected_parallax_hit_point.xy * 0.5f + 0.5f) * vec2(size));
}

// ------------------------------------------------------------------

vec3 world_position_from_depth(vec2 tex_coords, float ndc_depth)
{
    // Take texture coordinate and remap to [-1.0, 1.0] range.
    vec2 screen_pos = tex_coords * 2.0 - 1.0;

    // // Create NDC position.
    vec4 ndc_pos = vec4(screen_pos, ndc_depth, 1.0);

    // Transform back into world position.
    vec4 world_pos = ubo.view_proj_inverse * ndc_pos;

    // Undo projection.
    world_pos = world_pos / world_pos.w;

    return world_pos.xyz;
}

// ------------------------------------------------------------------------

float normal_edge_stopping_weight(vec3 a, vec3 b)
{
    return pow(max(dot(a, b), 0.0f), 32);
}

// ------------------------------------------------------------------------

float depth_edge_stopping_weight(float center_lin_depth, float sample_lin_depth)
{
    return clamp(1.0f - abs(center_lin_depth - sample_lin_depth), 0.0f, 1.0f);
}

// ------------------------------------------------------------------

vec4 sample_history(ivec2 current_coord, ivec2 history_coord, out float weight)
{
    vec4 history_color  = texelFetch(s_PrevColor, history_coord, 0);
    
    vec3  current_normal = texelFetch(s_GBuffer2, current_coord, 0).rgb;
    vec3  history_normal = texelFetch(s_GBuffer2, history_coord, 0).rgb;

    weight = normal_edge_stopping_weight(current_normal, history_normal);

    return history_color;
}

// ------------------------------------------------------------------
// MAIN -------------------------------------------------------------
// ------------------------------------------------------------------

void main()
{
    // Query the G-Buffer image size
    ivec2 size = textureSize(s_GBuffer1, 0);

    // Compute current pixel coord
    ivec2 current_coord = ivec2(gl_GlobalInvocationID.xy);
    
    // Compute the texture coord
    vec2 tex_coord = (vec2(current_coord) + vec2(0.5f)) / vec2(size); 

    // Compute world position for the current pixel 
    vec3 world_pos = world_position_from_depth(tex_coord, textureLod(s_GBufferDepth, tex_coord, 0.0f).r);

    // Sample the ray length for the current pixel 
    float ray_length = texelFetch(s_Hit, current_coord, 0).a;

    // Sample the motion vector for the current pixel
    vec4 motion = texelFetch(s_GBuffer3, current_coord, 0);

    // Sample the roughness for the current pixel
    float roughness = texelFetch(s_GBuffer1, current_coord, 0).a;

    // Compute the reprojected surface point coord
    ivec2 surface_point_coord = surface_point_reprojection(current_coord, motion.xy, size);
    
    // Compute the reprojected hit point coord
    ivec2 hit_point_coord = hit_point_reprojection(world_pos, ray_length, size);
    
    // If the pixel roughness is below the glossy roughness threshold, use the reprojected hit point coord,
    // otherwise you the reprojected surface point coord.
    ivec2 reprojected_coord = (roughness < GLOSSY_ROUGHNESS_THRESHOLD && ray_length > 0.0f) ? hit_point_coord : surface_point_coord;
    
    // Fetch current and previous pixels
    float edge_stopping_weight = 0.0f;
    vec4 current = texelFetch(s_Color, current_coord, 0);
    vec4 prev    = sample_history(current_coord, reprojected_coord, edge_stopping_weight);

    // Blend previous and current sample
    float feedback = (1.0f - u_PushConstants.alpha) * edge_stopping_weight;
    vec4 blended_sample = mix(current, prev, feedback);

    // Store blended sample into the storage image
    imageStore(i_ReprojectedColor, current_coord, blended_sample);
}

// ------------------------------------------------------------------