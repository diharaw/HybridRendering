#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : require

#define RAY_TRACING
#include "common.glsl"
#include "scene_descriptor_set.glsl"

// ------------------------------------------------------------------------
// DESCRIPTOR SETS --------------------------------------------------------
// ------------------------------------------------------------------------

layout(set = 1, binding = 0, rgba16f) uniform image2D i_Visibility;

layout(set = 2, binding = 0) uniform PerFrameUBO
{
    mat4  view_inverse;
    mat4  proj_inverse;
    mat4  view_proj_inverse;
    mat4  prev_view_proj;
    mat4  view_proj;
    vec4  cam_pos;
    Light light;
}
ubo;

layout(set = 3, binding = 0) uniform sampler2D s_GBuffer1; // RGB: Albedo, A: Roughness
layout(set = 3, binding = 1) uniform sampler2D s_GBuffer2; // RGB: Normal, A: Metallic
layout(set = 3, binding = 2) uniform sampler2D s_GBuffer3; // RG: Motion Vector, BA: -
layout(set = 3, binding = 3) uniform sampler2D s_GBufferDepth;

// ------------------------------------------------------------------------
// PAYLOADS ---------------------------------------------------------------
// ------------------------------------------------------------------------

layout(location = 0) rayPayloadEXT VisibilityPayload visibility_payload;

// ------------------------------------------------------------------------
// PUSH CONSTANTS ---------------------------------------------------------
// ------------------------------------------------------------------------

layout(push_constant) uniform PushConstants
{
    float bias;
    uint  num_frames;
}
u_PushConstants;

// ------------------------------------------------------------------------
// FUNCTIONS --------------------------------------------------------------
// ------------------------------------------------------------------------

vec3 world_position_from_depth(vec2 tex_coords, float ndc_depth)
{
    // Take texture coordinate and remap to [-1.0, 1.0] range.
    vec2 screen_pos = tex_coords * 2.0 - 1.0;

    // // Create NDC position.
    vec4 ndc_pos = vec4(screen_pos, ndc_depth, 1.0);

    // Transform back into world position.
    vec4 world_pos = ubo.view_proj_inverse * ndc_pos;

    // Undo projection.
    world_pos = world_pos / world_pos.w;

    return world_pos.xyz;
}

// ------------------------------------------------------------------------
// MAIN -------------------------------------------------------------------
// ------------------------------------------------------------------------

void main()
{
    RNG rng = rng_init(gl_LaunchIDEXT.xy, u_PushConstants.num_frames);

    // Compute current pixel coord
    const ivec2 current_coord = ivec2(gl_LaunchIDEXT.xy);
    const vec2  pixel_center  = vec2(current_coord) + vec2(0.5);
    const vec2  tex_coord     = pixel_center / vec2(gl_LaunchSizeEXT.xy);

    float depth = texelFetch(s_GBufferDepth, current_coord, 0).r;

    if (depth == 1.0f)
    {
        imageStore(i_Visibility, current_coord, vec4(0.0f));
        return;
    }

    vec3 position      = world_position_from_depth(tex_coord, depth);
    vec3 normal        = texture(s_GBuffer2, tex_coord).rgb;
    vec2 motion_vector = texture(s_GBuffer3, tex_coord).rg;

    uint  ray_flags = gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT;
    uint  cull_mask = 0xff;
    float tmin      = 0.001;
    float tmax      = 10000.0;

    vec2 rnd_sample = next_vec2(rng);

    vec3 shadow_ray_dir;

    const Light light = ubo.light;

    vec3 light_tangent   = normalize(cross(light_direction(light), vec3(0.0f, 1.0f, 0.0f)));
    vec3 light_bitangent = normalize(cross(light_tangent, light_direction(light)));

    // calculate disk point
    float point_radius = light_radius(light) * sqrt(rnd_sample.x);
    float point_angle  = rnd_sample.y * 2.0f * M_PI;
    vec2  disk_point   = vec2(point_radius * cos(point_angle), point_radius * sin(point_angle));
    shadow_ray_dir     = normalize(light_direction(light) + disk_point.x * light_tangent + disk_point.y * light_bitangent);

    // Ray bias
    position += normal * u_PushConstants.bias;

    visibility_payload.visible = false;
    traceRayEXT(u_TopLevelAS, ray_flags, cull_mask, 0, 0, 0, position, tmin, shadow_ray_dir, tmax, 0);

    imageStore(i_Visibility, current_coord, vec4(visibility_payload.visible ? 1.0f : 0.0f));
}

// ------------------------------------------------------------------------