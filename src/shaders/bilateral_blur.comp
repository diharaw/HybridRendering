#version 450

#extension GL_GOOGLE_include_directive : require

// ------------------------------------------------------------------
// DEFINES ----------------------------------------------------------
// ------------------------------------------------------------------

#define NUM_THREADS 32
#define EPSILON 0.0001f
#define GLOSSY_ROUGHNESS_THRESHOLD 0.05f

// ------------------------------------------------------------------
// INPUTS -----------------------------------------------------------
// ------------------------------------------------------------------

layout(local_size_x = NUM_THREADS, local_size_y = NUM_THREADS, local_size_z = 1) in;

// ------------------------------------------------------------------
// DESCRIPTOR SETS --------------------------------------------------
// ------------------------------------------------------------------

layout(set = 0, binding = 0, rgba16f) uniform image2D i_Output;

layout(set = 1, binding = 0) uniform sampler2D s_Input;

layout(set = 2, binding = 0) uniform sampler2D s_GBuffer1; // RGB: Albedo, A: Roughness
layout(set = 2, binding = 1) uniform sampler2D s_GBuffer2; // RGB: Normal, A: Metallic
layout(set = 2, binding = 2) uniform sampler2D s_GBuffer3; // RG: Motion Vector, BA: -
layout(set = 2, binding = 3) uniform sampler2D s_GBufferDepth;

// ------------------------------------------------------------------------
// PUSH CONSTANTS ---------------------------------------------------------
// ------------------------------------------------------------------------

layout(push_constant) uniform PushConstants
{
    vec4  z_buffer_params;
    float variance_threshold;
    float roughness_sigma_min;
    float roughness_sigma_max;
    int   radius;
    uint  roughness_weight;
    uint  depth_weight;
    uint  normal_weight;
    uint  g_buffer_mip;
}
u_PushConstants;

// ------------------------------------------------------------------
// FUNCTIONS --------------------------------------------------------
// ------------------------------------------------------------------

float gaussian_weight(int x, int y)
{
    uint weights[] = { 6, 4, 1 };
    return float(weights[abs(x)] * weights[abs(y)]) / 256.0f;
}

// ------------------------------------------------------------------

// Convert an exponential depth value from the current views' projection to linear 0..1 depth
float linear_01_depth(float z)
{
    return 1.0 / (u_PushConstants.z_buffer_params.x * z + u_PushConstants.z_buffer_params.y);
}

// ------------------------------------------------------------------------

float normal_edge_stopping_weight(vec3 a, vec3 b)
{
    return pow(max(dot(a, b), 0.0f), 32);
}

// ------------------------------------------------------------------------

float depth_edge_stopping_weight(float center_lin_depth, float sample_lin_depth)
{
    return clamp(1.0f - abs(center_lin_depth - sample_lin_depth), 0.0f, 1.0f);
}

// ------------------------------------------------------------------------

float roughness_edge_stopping_weight(float center_roughness, float sample_roughness)
{
    return 1.0 - smoothstep(u_PushConstants.roughness_sigma_min, u_PushConstants.roughness_sigma_max, abs(center_roughness - sample_roughness));
}

// ------------------------------------------------------------------------

float edge_stopping_weight(ivec2 sample_coord, float center_depth, vec3 center_normal, float center_roughness)
{
    float weight = 1.0f;

    if (u_PushConstants.depth_weight == 1)
    {
        float sample_depth = linear_01_depth(texelFetch(s_GBufferDepth, sample_coord, u_PushConstants.g_buffer_mip).r);

        weight *= depth_edge_stopping_weight(center_depth, sample_depth);
    }
    if (u_PushConstants.normal_weight == 1)
    {
        vec3 sample_normal = texelFetch(s_GBuffer2, sample_coord, u_PushConstants.g_buffer_mip).rgb;

        weight *= normal_edge_stopping_weight(center_normal, sample_normal);
    }
    if (u_PushConstants.roughness_weight == 1)
    {
        float sample_roughness = texelFetch(s_GBuffer1, sample_coord, u_PushConstants.g_buffer_mip).a;

        weight *= roughness_edge_stopping_weight(center_roughness, sample_roughness);
    }

    return weight;
}

// ------------------------------------------------------------------

vec3 bilateral_blur(ivec2 current_coord)
{
    float center_roughness = texelFetch(s_GBuffer1, current_coord, u_PushConstants.g_buffer_mip).a;
    float center_depth     = linear_01_depth(texelFetch(s_GBufferDepth, current_coord, u_PushConstants.g_buffer_mip).r);
    vec3  center_normal    = texelFetch(s_GBuffer2, current_coord, u_PushConstants.g_buffer_mip).rgb;

    const int radius = u_PushConstants.radius;

    vec3  total_color  = vec3(0.0f);
    float total_weight = 0.0f;

    for (int dx = -radius; dx <= radius; dx++)
    {
        for (int dy = -radius; dy <= radius; dy++)
        {
            ivec2 sample_coord = current_coord + ivec2(dx, dy);
            vec3  sample_color = texelFetch(s_Input, sample_coord, 0).rgb;

            float weight = gaussian_weight(dx, dy) * edge_stopping_weight(sample_coord, center_depth, center_normal, center_roughness);

            total_color += weight * sample_color;
            total_weight += weight;
        }
    }

    return total_color / max(total_weight, 0.0001f);
}

// ------------------------------------------------------------------

float luminance(vec3 rgb)
{
    return dot(rgb, vec3(0.2126f, 0.7152f, 0.0722f));
}

// ------------------------------------------------------------------

float compute_temporal_variance(float current_sample_luma, float history_sample_luma)
{
    return abs(current_sample_luma - history_sample_luma) / max(max(current_sample_luma, history_sample_luma), EPSILON);
}

// ------------------------------------------------------------------
// MAIN -------------------------------------------------------------
// ------------------------------------------------------------------

void main()
{
    // Query the G-Buffer image size
    ivec2 size = textureSize(s_GBuffer1, u_PushConstants.g_buffer_mip);

    // Compute current pixel coord
    ivec2 current_coord = ivec2(gl_GlobalInvocationID.xy);

    // Sample the center color and variance
    vec4  center_color     = texelFetch(s_Input, current_coord, 0);
    float center_roughness = texelFetch(s_GBuffer1, current_coord, u_PushConstants.g_buffer_mip).a;

    if (center_roughness < GLOSSY_ROUGHNESS_THRESHOLD)
    {
        imageStore(i_Output, current_coord, vec4(center_color.xyz, 0.0f));
        return;
    }

    vec3  color    = center_color.xyz;
    float variance = center_color.a;

    if (center_color.a > u_PushConstants.variance_threshold)
    {
        color    = bilateral_blur(current_coord);
        variance = compute_temporal_variance(luminance(color.xyz), luminance(center_color.xyz));
    }

    // Store blended sample into the storage image
    imageStore(i_Output, current_coord, vec4(color, variance));
}

// ------------------------------------------------------------------