#version 450

#extension GL_GOOGLE_include_directive : require

#include "common.glsl"

// ------------------------------------------------------------------
// DEFINES ----------------------------------------------------------
// ------------------------------------------------------------------

#define NUM_THREADS 32
#define RADIUS 1
#define SPATIAL_REUSE_SIZE 3

// ------------------------------------------------------------------
// INPUTS -----------------------------------------------------------
// ------------------------------------------------------------------

layout(local_size_x = NUM_THREADS, local_size_y = NUM_THREADS, local_size_z = 1) in;

// ------------------------------------------------------------------
// DESCRIPTOR SETS --------------------------------------------------
// ------------------------------------------------------------------

layout(set = 0, binding = 0, rgba16f) uniform image2D i_ResolvedColor;

layout(set = 1, binding = 0) uniform sampler2D i_Color;
layout(set = 1, binding = 1) uniform sampler2D i_Hit;

layout(set = 2, binding = 0) uniform sampler2D s_GBuffer1; // RGB: Albedo, A: Roughness
layout(set = 2, binding = 1) uniform sampler2D s_GBuffer2; // RGB: Normal, A: Metallic
layout(set = 2, binding = 2) uniform sampler2D s_GBuffer3; // RG: Motion Vector, BA: -
layout(set = 2, binding = 3) uniform sampler2D s_GBufferDepth;

layout(set = 3, binding = 0) uniform PerFrameUBO
{
    mat4  view_inverse;
    mat4  proj_inverse;
    mat4  view_proj_inverse;
    mat4  prev_view_proj;
    mat4  view_proj;
    vec4  cam_pos;
    Light light;
}
ubo;

// ------------------------------------------------------------------------
// PUSH CONSTANTS ---------------------------------------------------------
// ------------------------------------------------------------------------

layout(push_constant) uniform PushConstants
{
    uint bypass;
}
u_PushConstants;

// ------------------------------------------------------------------------
// FUNCTIONS --------------------------------------------------------------
// ------------------------------------------------------------------------

vec3 world_position_from_depth(vec2 tex_coords, float ndc_depth)
{
    // Take texture coordinate and remap to [-1.0, 1.0] range.
    vec2 screen_pos = tex_coords * 2.0 - 1.0;

    // // Create NDC position.
    vec4 ndc_pos = vec4(screen_pos, ndc_depth, 1.0);

    // Transform back into world position.
    vec4 world_pos = ubo.view_proj_inverse * ndc_pos;

    // Undo projection.
    world_pos = world_pos / world_pos.w;

    return world_pos.xyz;
}

// ------------------------------------------------------------------

float distribution_ggx(vec3 N, vec3 H, float roughness)
{
    float a      = roughness * roughness;
    float a2     = a * a;
    float NdotH  = max(dot(N, H), 0.0);
    float NdotH2 = NdotH * NdotH;

    float nom   = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom       = M_PI * denom * denom;

    return nom / max(EPSILON, denom);
}

// ------------------------------------------------------------------

float geometry_schlick_ggx(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r * r) / 8.0;

    float nom   = NdotV;
    float denom = NdotV * (1.0 - k) + k;

    return nom / max(EPSILON, denom);
}

// ------------------------------------------------------------------

float geometry_smith(vec3 N, vec3 V, vec3 L, float roughness)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2  = geometry_schlick_ggx(NdotV, roughness);
    float ggx1  = geometry_schlick_ggx(NdotL, roughness);

    return ggx1 * ggx2;
}

// ------------------------------------------------------------------------

void local_brdf(in vec2 uv, in ivec2 coord, in vec3 start_pos, in float roughness, in vec3 N, in vec3 Wo, out vec3 sample_color, out float weight)
{
    vec4 value0 = textureLod(i_Color, uv, 0.0f);
    vec3 end_pos = texelFetch(i_Hit, coord, 0).rgb;

    vec3 Li = value0.rgb;
    float pdf = value0.a;
    vec3 Wi = normalize(end_pos - start_pos);
    vec3 Wh = normalize(Wo + Wi);

    // Cook-Torrance BRDF
    float NDF = distribution_ggx(N, Wh, roughness);
    float G   = geometry_smith(N, Wo, Wi, roughness);

    float nominator   = NDF * G;
    float denominator = 4 * max(dot(N, Wo), 0.0) * max(dot(N, Wi), 0.0); 
    float specular    = (nominator) / max(EPSILON, denominator);

    sample_color = Li;
    weight = specular / max(EPSILON, pdf);
}

// ------------------------------------------------------------------
// MAIN -------------------------------------------------------------
// ------------------------------------------------------------------

void main()
{
    ivec2 size      = textureSize(s_GBuffer1, 0);
    vec2 rcp_size = 1.0f / vec2(size);
    vec2  tex_coord = vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y) / vec2(size);

    vec4 g_buffer_data_1 = texelFetch(s_GBuffer1, ivec2(gl_GlobalInvocationID.xy), 0);
    vec4 g_buffer_data_2 = texelFetch(s_GBuffer2, ivec2(gl_GlobalInvocationID.xy), 0);

    const vec3  world_pos  = world_position_from_depth(tex_coord, texelFetch(s_GBufferDepth, ivec2(gl_GlobalInvocationID.xy), 0).r);
    const float roughness  = g_buffer_data_1.a;

    const vec3 N  = g_buffer_data_2.rgb;
    const vec3 Wo = normalize(ubo.cam_pos.xyz - world_pos);

    vec4 center = texelFetch(i_Color, ivec2(gl_GlobalInvocationID.xy), 0);

    if (center.w == 0.0f || roughness < 0.05f || u_PushConstants.bypass == 1)
    {
        imageStore(i_ResolvedColor, ivec2(gl_GlobalInvocationID.xy), center);
        return;
    }

    vec3 sum_color = vec3(0.0f);
    float sum_weight = 0.0f;

    for (int y = -RADIUS; y <= RADIUS; y++)
    {
        for (int x = -RADIUS; x <= RADIUS; x++)
        {
            ivec2 offset = ivec2(x, y) * SPATIAL_REUSE_SIZE;
            ivec2 coord = ivec2(gl_GlobalInvocationID.xy) + offset;
            vec2 uv = tex_coord + vec2(offset) * rcp_size;

            if (any(lessThan(coord, ivec2(1, 1))) || any(greaterThan(coord, size - ivec2(1, 1)))) 
                continue;

            vec3 sample_color;
            float weight;

            local_brdf(uv, coord, world_pos, roughness, N, Wo, sample_color, weight);

            sum_color += sample_color * weight;
            sum_weight += weight;
        }
    }

    vec3 resolved_color = sum_weight == 0.0f ? center.rgb : sum_color / sum_weight;

    imageStore(i_ResolvedColor, ivec2(gl_GlobalInvocationID.xy), vec4(resolved_color, 0.0f));
}

// ------------------------------------------------------------------