#version 450

#extension GL_GOOGLE_include_directive : require

#include "common.glsl"

// ------------------------------------------------------------------
// DEFINES ----------------------------------------------------------
// ------------------------------------------------------------------

#define NUM_THREADS 32
#define NORMAL_SIGMA 32.0f
#define DEPTH_SIGMA 0.2f
#define EPSILON 0.0001f

// ------------------------------------------------------------------
// INPUTS -----------------------------------------------------------
// ------------------------------------------------------------------

layout(local_size_x = NUM_THREADS, local_size_y = NUM_THREADS, local_size_z = 1) in;

// ------------------------------------------------------------------
// DESCRIPTOR SETS --------------------------------------------------
// ------------------------------------------------------------------

layout(set = 0, binding = 0, rgba16f) uniform image2D i_ResolvedColor;

layout(set = 1, binding = 0) uniform sampler2D s_Color;
layout(set = 1, binding = 1) uniform sampler2D s_Hit;

layout(set = 2, binding = 0) uniform sampler2D s_GBuffer1; // RGB: Albedo, A: Roughness
layout(set = 2, binding = 1) uniform sampler2D s_GBuffer2; // RGB: Normal, A: Metallic
layout(set = 2, binding = 2) uniform sampler2D s_GBuffer3; // RG: Motion Vector, BA: -
layout(set = 2, binding = 3) uniform sampler2D s_GBufferDepth;
layout(set = 2, binding = 4) uniform sampler2D s_GBufferLinearDepth;

layout(set = 3, binding = 0) uniform PerFrameUBO
{
    mat4  view_inverse;
    mat4  proj_inverse;
    mat4  view_proj_inverse;
    mat4  prev_view_proj;
    mat4  view_proj;
    vec4  cam_pos;
    Light light;
}
ubo;

// ------------------------------------------------------------------------
// PUSH CONSTANTS ---------------------------------------------------------
// ------------------------------------------------------------------------

layout(push_constant) uniform PushConstants
{
    uint bypass;
}
u_PushConstants;

// ------------------------------------------------------------------------
// FUNCTIONS --------------------------------------------------------------
// ------------------------------------------------------------------------

vec3 world_position_from_depth(vec2 tex_coords, float ndc_depth)
{
    // Take texture coordinate and remap to [-1.0, 1.0] range.
    vec2 screen_pos = tex_coords * 2.0 - 1.0;

    // // Create NDC position.
    vec4 ndc_pos = vec4(screen_pos, ndc_depth, 1.0);

    // Transform back into world position.
    vec4 world_pos = ubo.view_proj_inverse * ndc_pos;

    // Undo projection.
    world_pos = world_pos / world_pos.w;

    return world_pos.xyz;
}

// ------------------------------------------------------------------

float distribution_ggx(vec3 N, vec3 H, float roughness)
{
    float a      = roughness * roughness;
    float a2     = a * a;
    float NdotH  = max(dot(N, H), 0.0);
    float NdotH2 = NdotH * NdotH;

    float nom   = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom       = M_PI * denom * denom;

    return nom / max(EPSILON, denom);
}

// ------------------------------------------------------------------

float geometry_schlick_ggx(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r * r) / 8.0;

    float nom   = NdotV;
    float denom = NdotV * (1.0 - k) + k;

    return nom / max(EPSILON, denom);
}

// ------------------------------------------------------------------

float geometry_smith(vec3 N, vec3 V, vec3 L, float roughness)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2  = geometry_schlick_ggx(NdotV, roughness);
    float ggx1  = geometry_schlick_ggx(NdotL, roughness);

    return ggx1 * ggx2;
}

// ------------------------------------------------------------------------

float normal_edge_stopping_weight(vec3 a, vec3 b)
{
    return pow(max(dot(a, b), 0.0f), 32);
}

// ------------------------------------------------------------------------

float depth_edge_stopping_weight(float center_lin_depth, float sample_lin_depth)
{
    return 1.0f / (EPSILON + abs(center_lin_depth - sample_lin_depth));
}

// ------------------------------------------------------------------
// MAIN -------------------------------------------------------------
// ------------------------------------------------------------------

void main()
{
    ivec2 size      = textureSize(s_GBuffer1, 0);
    vec2  rcp_size  = 1.0f / vec2(size);
    vec2  tex_coord = vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y) / vec2(size);

    float center_roughness = texelFetch(s_GBuffer1, ivec2(gl_GlobalInvocationID.xy), 0).a;
    vec4 center_radiance = textureLod(s_Color, tex_coord, 0.0f);
    vec3 center_normal = texelFetch(s_GBuffer2, ivec2(gl_GlobalInvocationID.xy), 0).rgb;
    float center_lin_depth = texelFetch(s_GBufferLinearDepth, ivec2(gl_GlobalInvocationID.xy), 0).x;

    if (center_radiance.w == 0.0f || u_PushConstants.bypass == 1)
    {
        imageStore(i_ResolvedColor, ivec2(gl_GlobalInvocationID.xy), center_radiance);
        return;
    }

    const ivec2 reuse_offsets[] = {
        ivec2(0, 1),
        ivec2(-2, 1),
        ivec2(2, -3),
        ivec2(-3, 0),
        ivec2(1, 2),
        ivec2(-1, -2),
        ivec2(3, 0),
        ivec2(-3, 3),
        ivec2(0, -3),
        ivec2(-1, -1),
        ivec2(2, 1),
        ivec2(-2, -2),
        ivec2(1, 0),
        ivec2(0, 2),
        ivec2(3, -1)
    };

    vec3  sum_color  = center_radiance.xyz;
    float sum_weight = 1.0f;

    const int sample_count = 15;

    for (int i = 0; i < sample_count; i++)
    {
        ivec2 offset = reuse_offsets[i];
        ivec2 coord  = ivec2(gl_GlobalInvocationID.xy) + offset;
        vec2  uv     = tex_coord + vec2(offset) * rcp_size;
        
        if (any(lessThan(coord, ivec2(1, 1))) || any(greaterThan(coord, size - ivec2(1, 1))))
            continue;
        
        vec3 sample_radiance = textureLod(s_Color, uv, 0.0f).rgb;
        vec3 sample_normal = texelFetch(s_GBuffer2, coord, 0).xyz;
        float sample_lin_depth = texelFetch(s_GBufferLinearDepth, coord, 0).x;

        float weight = normal_edge_stopping_weight(center_normal, sample_normal) * depth_edge_stopping_weight(center_lin_depth, sample_lin_depth);

        sum_color += sample_radiance * weight;
        sum_weight += weight;
    }

    vec3 resolved_color = sum_color / sum_weight;

    imageStore(i_ResolvedColor, ivec2(gl_GlobalInvocationID.xy), vec4(resolved_color, 0.0f));
}

// ------------------------------------------------------------------