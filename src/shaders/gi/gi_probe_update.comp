#version 450

// ------------------------------------------------------------------
// DEFINES ----------------------------------------------------------
// ------------------------------------------------------------------

#define NUM_THREADS_X 32
#define NUM_THREADS_Y 32

// ------------------------------------------------------------------
// INPUTS -----------------------------------------------------------
// ------------------------------------------------------------------

layout(local_size_x = NUM_THREADS_X, local_size_y = NUM_THREADS_Y, local_size_z = 1) in;

// ------------------------------------------------------------------
// DESCRIPTOR SETS --------------------------------------------------
// ------------------------------------------------------------------

layout(set = 0, binding = 0, rgba16f) uniform image2D i_OutputIrradiance;
layout(set = 0, binding = 1, rg16f) uniform image2D i_OutputDepth;

layout(set = 1, binding = 0) uniform sampler2D s_InputIrradiance;
layout(set = 1, binding = 1) uniform sampler2D s_InputDepth;

layout(set = 2, binding = 0) uniform sampler2D s_InputRadiance;
layout(set = 2, binding = 1) uniform sampler2D s_InputDirectionDepth;

// ------------------------------------------------------------------
// PUSH CONSTANTS ---------------------------------------------------
// ------------------------------------------------------------------

layout(push_constant) uniform PushConstants
{
    vec3  grid_start_position;
    vec3  grid_step;
    ivec3 probe_counts;
    float max_distance;
    float depth_sharpness;
    float hysteresis;
    int   probe_side_length;
    int   texture_width;
    int   texture_height;
    int   rays_per_probe;
    int   is_irradiance;
}
u_PushConstants;

// ------------------------------------------------------------------
// CONSTANTS --------------------------------------------------------
// ------------------------------------------------------------------

const float FLT_EPS = 0.00000001;

// ------------------------------------------------------------------
// FUNCTIONS --------------------------------------------------------
// ------------------------------------------------------------------

int probe_id(vec2 texel_xy)
{
    int probe_with_border_side = u_PushConstants.probe_side_length + 2;
    int probes_per_side        = (u_PushConstants.texture_width - 2) / probe_with_border_side;
    return int(texel_xy.x / probe_with_border_side) + probes_per_side * int(texel_xy.y / probe_with_border_side);
}

// ------------------------------------------------------------------

// Compute normalized oct coord, mapping top left of top left pixel to (-1,-1)
vec2 normalized_oct_coord(ivec2 frag_coord)
{
    int probe_with_border_side = u_PushConstants.probe_side_length + 2;

    vec2 oct_frag_coord = ivec2((frag_coord.x - 2) % probe_with_border_side, (frag_coord.y - 2) % probe_with_border_side);
    // Add back the half pixel to get pixel center normalized coordinates
    return (vec2(oct_frag_coord) + vec2(0.5f)) * (2.0f / float(u_PushConstants.probe_side_length)) - vec2(1.0f, 1.0f);
}

// ------------------------------------------------------------------

float sign_not_zero(in float k)
{
    return (k >= 0.0) ? 1.0 : -1.0;
}

// ------------------------------------------------------------------

vec2 sign_not_zero(in vec2 v)
{
    return vec2(sign_not_zero(v.x), sign_not_zero(v.y));
}

// ------------------------------------------------------------------

vec3 oct_decode(vec2 o)
{
    vec3 v = vec3(o.x, o.y, 1.0 - abs(o.x) - abs(o.y));

    if (v.z < 0.0)
        v.xy = (1.0 - abs(v.yx)) * sign_not_zero(v.xy);

    return normalize(v);
}

// ------------------------------------------------------------------

float square(float v)
{
    return v * v;
}

// ------------------------------------------------------------------

bool is_border_texel()
{
    if (gl_GlobalInvocationID.x == 0 || gl_GlobalInvocationID.y == 0)
        return true;

    if (gl_GlobalInvocationID.x == (u_PushConstants.texture_width  - 1) || gl_GlobalInvocationID.y == (u_PushConstants.texture_height - 1))
        return true;

    int probe_with_border_side = u_PushConstants.probe_side_length + 2;

    if ((gl_GlobalInvocationID.x % probe_with_border_side) == 0 || (gl_GlobalInvocationID.x % probe_with_border_side) == 1)
        return true;

    if ((gl_GlobalInvocationID.y % probe_with_border_side) == 0 || (gl_GlobalInvocationID.y % probe_with_border_side) == 1)
        return true;
   
    return false;
}

// ------------------------------------------------------------------
// MAIN -------------------------------------------------------------
// ------------------------------------------------------------------

void main()
{
    const ivec2 current_coord = ivec2(gl_GlobalInvocationID.xy);

    if (!is_border_texel())
    {
        const int   relative_probe_id   = probe_id(current_coord);
        const float energy_conservation = 0.95f;

        vec3  result       = vec3(0.0f);
        float total_weight = 0.0f;

        // For each ray
        for (int r = 0; r < u_PushConstants.rays_per_probe; ++r)
        {
            ivec2 C = ivec2(r, relative_probe_id);

            vec4 ray_direction_depth = texelFetch(s_InputDirectionDepth, C, 0);

            vec3  ray_direction      = ray_direction_depth.xyz;
            float ray_probe_distance = min(u_PushConstants.max_distance, ray_direction_depth.w - 0.01f);
            vec3  ray_hit_radiance   = texelFetch(s_InputRadiance, C, 0).xyz * energy_conservation;

            // Detect misses and force depth
            if (ray_probe_distance == -1.0f)
                ray_probe_distance = u_PushConstants.max_distance;

            vec3 texel_direction = oct_decode(normalized_oct_coord(current_coord));

            float weight = 0.0f;

            if (u_PushConstants.is_irradiance == 1)
                weight = max(0.0, dot(texel_direction, ray_direction));
            else
                weight = pow(max(0.0, dot(texel_direction, ray_direction)), u_PushConstants.depth_sharpness);

            if (weight >= FLT_EPS)
            {
                if (u_PushConstants.is_irradiance == 1)
                    result += vec3(ray_hit_radiance * weight);
                else
                    result += vec3(ray_probe_distance * weight, square(ray_probe_distance) * weight, 0.0);

                total_weight += weight;
            }
        }

        if (total_weight > FLT_EPS)
            result /= total_weight;

        // Temporal Accumulation
        vec3 prev_result;

        if (u_PushConstants.is_irradiance == 1)
            prev_result = texelFetch(s_InputIrradiance, current_coord, 0).rgb;
        else
            prev_result = texelFetch(s_InputDepth, current_coord, 0).rgb;

        result = mix(result, prev_result, u_PushConstants.hysteresis);

        if (u_PushConstants.is_irradiance == 1)
            imageStore(i_OutputIrradiance, current_coord, vec4(result, 1.0));
        else
            imageStore(i_OutputDepth, current_coord, vec4(result, 1.0));

        // Update borders
        const ivec2 coord_without_outer_border = current_coord - ivec2(1);
        const ivec2 probe_coord = coord_without_outer_border % ivec2(u_PushConstants.probe_side_length + 2);
        const ivec2 probe_coord_without_border = probe_coord - ivec2(1);

        // Top row
        if (probe_coord_without_border.y == 0)
        {
            const ivec2 column_start_coord = current_coord - probe_coord_without_border - ivec2(1, 0);
            const ivec2 border_texel = column_start_coord + ivec2((u_PushConstants.probe_side_length - probe_coord_without_border.x), -1);

            if (u_PushConstants.is_irradiance == 1)
                imageStore(i_OutputIrradiance, border_texel, vec4(1.0, 0.0f, 0.0f, 0.0f));
            else
                imageStore(i_OutputDepth, border_texel, vec4(1.0, 0.0f, 0.0f, 0.0f));
        }

        // Bottom row
        if (probe_coord_without_border.y == (u_PushConstants.probe_side_length - 1))
        {
            const ivec2 column_start_coord = current_coord - probe_coord_without_border + ivec2(0, u_PushConstants.probe_side_length - 1)  - ivec2(1, 0);
            const ivec2 border_texel = column_start_coord + ivec2((u_PushConstants.probe_side_length - probe_coord_without_border.x), 1);

            if (u_PushConstants.is_irradiance == 1)
                imageStore(i_OutputIrradiance, border_texel, vec4(1.0, 0.0f, 0.0f, 0.0f));
            else
                imageStore(i_OutputDepth, border_texel, vec4(1.0, 0.0f, 0.0f, 0.0f));
        }

        // Left column
        if (probe_coord_without_border.x == 0)
        {
            const ivec2 column_start_coord = current_coord - probe_coord_without_border - ivec2(0, 1);
            const ivec2 border_texel = column_start_coord + ivec2(-1, (u_PushConstants.probe_side_length - probe_coord_without_border.y));

            if (u_PushConstants.is_irradiance == 1)
                imageStore(i_OutputIrradiance, border_texel, vec4(1.0, 0.0f, 0.0f, 0.0f));
            else
                imageStore(i_OutputDepth, border_texel, vec4(1.0, 0.0f, 0.0f, 0.0f));
        }

        // Right column
        if (probe_coord_without_border.x == (u_PushConstants.probe_side_length - 1))
        {
            const ivec2 column_start_coord = current_coord - probe_coord_without_border + ivec2(u_PushConstants.probe_side_length - 1, 0) - ivec2(0, 1);
            const ivec2 border_texel = column_start_coord + ivec2(1, (u_PushConstants.probe_side_length - probe_coord_without_border.y));

            if (u_PushConstants.is_irradiance == 1)
                imageStore(i_OutputIrradiance, border_texel, vec4(1.0, 0.0f, 0.0f, 0.0f));
            else
                imageStore(i_OutputDepth, border_texel, vec4(1.0, 0.0f, 0.0f, 0.0f));
        }
    }
}

// ------------------------------------------------------------------