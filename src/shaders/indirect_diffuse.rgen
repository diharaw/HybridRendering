#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : require

#define RAY_TRACING
#include "common.glsl"
#include "scene_descriptor_set.glsl"

// ------------------------------------------------------------------------
// DESCRIPTOR SETS --------------------------------------------------------
// ------------------------------------------------------------------------

layout(set = 1, binding = 0, rgba16f) uniform image2D i_Color;

layout(set = 2, binding = 0) uniform PerFrameUBO
{
    mat4  view_inverse;
    mat4  proj_inverse;
    mat4  view_proj_inverse;
    mat4  prev_view_proj;
    mat4  view_proj;
    vec4  cam_pos;
    Light light;
}
ubo;

layout(set = 2, binding = 1) uniform sampler2D s_BlueNoise1;

layout(set = 3, binding = 0) uniform sampler2D s_GBuffer1; // RGB: Albedo, A: Roughness
layout(set = 3, binding = 1) uniform sampler2D s_GBuffer2; // RGB: Normal, A: Metallic
layout(set = 3, binding = 2) uniform sampler2D s_GBuffer3; // RG: Motion Vector, BA: -
layout(set = 3, binding = 3) uniform sampler2D s_GBufferDepth;

// ------------------------------------------------------------------------
// PUSH CONSTANTS ---------------------------------------------------------
// ------------------------------------------------------------------------

layout(push_constant) uniform PushConstants
{
    float bias;
    uint  num_frames;
    uint  max_ray_depth;
    uint  sample_sky;
}
u_PushConstants;

// ------------------------------------------------------------------------
// PAYLOADS ---------------------------------------------------------------
// ------------------------------------------------------------------------

layout(location = 0) rayPayloadEXT IndirectDiffusePayload p_PathTracePayload;

// ------------------------------------------------------------------------
// FUNCTIONS --------------------------------------------------------------
// ------------------------------------------------------------------------

mat3 make_rotation_matrix(vec3 z)
{
    const vec3 ref = abs(dot(z, vec3(0, 1, 0))) > 0.99f ? vec3(0, 0, 1) : vec3(0, 1, 0);

    const vec3 x = normalize(cross(ref, z));
    const vec3 y = cross(z, x);

    return mat3(x, y, z);
}

// ------------------------------------------------------------------------

vec3 sample_cosine_lobe(in vec3 n, in vec2 r)
{
    vec2 rand_sample = max(vec2(0.00001f), r);

    const float phi = 2.0f * M_PI * rand_sample.y;

    const float cos_theta = sqrt(rand_sample.x);
    const float sin_theta = sqrt(1 - rand_sample.x);

    vec3 t = vec3(sin_theta * cos(phi), sin_theta * sin(phi), cos_theta);

    return normalize(make_rotation_matrix(n) * t);
}

// ------------------------------------------------------------------------

float pdf_cosine_lobe(in float ndotl)
{
    return ndotl / M_PI;
}

// ------------------------------------------------------------------------

vec3 evaluate_lambert(in vec3 albedo)
{
    return albedo / M_PI;
}

// ------------------------------------------------------------------------

vec3 sample_lambert(in vec3 albedo, in vec3 N, in vec3 Wo, in RNG rng, out vec3 Wi, out float pdf, out float NdotL)
{
    vec3 Wh;

    Wi = sample_cosine_lobe(N, next_vec2(rng));
    Wh = normalize(Wo + Wi);

    NdotL = max(dot(N, Wi), 0.0);
    pdf = pdf_cosine_lobe(NdotL);

    return evaluate_lambert(albedo);
}

// ------------------------------------------------------------------------

vec3 world_position_from_depth(vec2 tex_coords, float ndc_depth)
{
    // Take texture coordinate and remap to [-1.0, 1.0] range.
    vec2 screen_pos = tex_coords * 2.0 - 1.0;

    // // Create NDC position.
    vec4 ndc_pos = vec4(screen_pos, ndc_depth, 1.0);

    // Transform back into world position.
    vec4 world_pos = ubo.view_proj_inverse * ndc_pos;

    // Undo projection.
    world_pos = world_pos / world_pos.w;

    return world_pos.xyz;
}

// ------------------------------------------------------------------------
// MAIN -------------------------------------------------------------------
// ------------------------------------------------------------------------

void main()
{
    const ivec2 quarter_res_pixel_coord = ivec2(gl_LaunchIDEXT.xy);
    const ivec2 noise_coord             = ((quarter_res_pixel_coord / 2) * (int(u_PushConstants.num_frames) / 2) * ivec2(3, 7)) & 31;
    const int   subpixel_idx            = int(texelFetch(s_BlueNoise1, noise_coord, 0).r * 3.0f) + int(u_PushConstants.num_frames);
    const ivec2 full_res_pixel_coord    = quarter_res_pixel_coord * 2 + ivec2(subpixel_idx & 1, (subpixel_idx >> 1) & 1);
    const ivec2 full_res_size           = ivec2(gl_LaunchSizeEXT.xy) * 2;
    const vec2  pixel_center            = vec2(full_res_pixel_coord) + vec2(0.5);
    const vec2  tex_coord               = pixel_center / vec2(full_res_size);

    float depth = texelFetch(s_GBufferDepth, full_res_pixel_coord, 0).r;

    if (depth == 1.0f)
    {
        imageStore(i_Color, quarter_res_pixel_coord, vec4(0.0f));
        return;
    }

    vec3  albedo = texelFetch(s_GBuffer1, full_res_pixel_coord, 0).rgb;
    vec3  P      = world_position_from_depth(tex_coord, depth);
    vec3  N      = texelFetch(s_GBuffer2, full_res_pixel_coord, 0).rgb;
    vec3  Wo     = normalize(ubo.cam_pos.xyz - P.xyz);

    uint  ray_flags  = gl_RayFlagsOpaqueEXT;
    uint  cull_mask  = 0xff;
    float tmin       = 0.001;
    float tmax       = 10000.0;
    vec3  ray_origin = P + N * u_PushConstants.bias;

    p_PathTracePayload.rng = rng_init(gl_LaunchIDEXT.xy, u_PushConstants.num_frames);

    vec3 Wi;
    float pdf;
    float NdotL;
    vec3 brdf = sample_lambert(albedo, N, Wo, p_PathTracePayload.rng, Wi, pdf, NdotL);
    
    p_PathTracePayload.L = vec3(0.0f); 
    p_PathTracePayload.T = vec3(1.0f);//(brdf * NdotL) / pdf;
    p_PathTracePayload.depth = 0;

    traceRayEXT(u_TopLevelAS, ray_flags, cull_mask, 0, 0, 0, ray_origin, tmin, Wi, tmax, 0);

    imageStore(i_Color, quarter_res_pixel_coord, vec4(p_PathTracePayload.L, 0.0f));
}

// ------------------------------------------------------------------------