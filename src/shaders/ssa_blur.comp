#version 450

// ------------------------------------------------------------------
// DEFINES ----------------------------------------------------------
// ------------------------------------------------------------------

#define NUM_THREADS_X 32
#define NUM_THREADS_Y 32
#define DEPTH_FACTOR 0.5

// ------------------------------------------------------------------
// INPUTS -----------------------------------------------------------
// ------------------------------------------------------------------

layout(local_size_x = NUM_THREADS_X, local_size_y = NUM_THREADS_Y, local_size_z = 1) in;

// ------------------------------------------------------------------
// DESCRIPTOR SETS --------------------------------------------------
// ------------------------------------------------------------------

layout(set = 0, binding = 0, rgba16f) uniform image2D i_Output;

layout(set = 1, binding = 0) uniform sampler2D s_Input;

layout(set = 2, binding = 0) uniform sampler2D s_GBuffer1; // RGB: Albedo, A: Roughness
layout(set = 2, binding = 1) uniform sampler2D s_GBuffer2; // RGB: Normal, A: Metallic
layout(set = 2, binding = 2) uniform sampler2D s_GBuffer3; // RG: Motion Vector, BA: -
layout(set = 2, binding = 3) uniform sampler2D s_GBufferDepth;

// ------------------------------------------------------------------------
// PUSH CONSTANTS ---------------------------------------------------------
// ------------------------------------------------------------------------

layout(push_constant) uniform PushConstants
{
    vec4 z_buffer_params;
    int  g_buffer_mip;
}
u_PushConstants;

// ------------------------------------------------------------------
// CONSTANTS --------------------------------------------------------
// ------------------------------------------------------------------

const ivec2 g_offsets[15] = ivec2[](
    ivec2(-1, -1),
    ivec2(0, -1),
    ivec2(1, -1),
    ivec2(2, -1),
    ivec2(-1, 0),
    ivec2(1, 0),
    ivec2(2, 0),
    ivec2(-1, 1),
    ivec2(0, 1),
    ivec2(1, 1),
    ivec2(2, 1),
    ivec2(-1, 2),
    ivec2(0, 2),
    ivec2(1, 2),
    ivec2(2, 2));

// ------------------------------------------------------------------
// FUNCTIONS --------------------------------------------------------
// ------------------------------------------------------------------

float linear_eye_depth(float z)
{
    return 1.0 / (u_PushConstants.z_buffer_params.z * z + u_PushConstants.z_buffer_params.w);
}

// ------------------------------------------------------------------------

float normal_edge_stopping_weight(vec3 center_normal, vec3 sample_normal)
{
    return pow(abs(dot(center_normal, sample_normal)), 32);
}

// ------------------------------------------------------------------------

float depth_edge_stopping_weight(float center_lin_depth, float sample_lin_depth)
{
    float depth_diff = abs(center_lin_depth - sample_lin_depth);
    float d_factor   = depth_diff * DEPTH_FACTOR;
    return exp(-(d_factor * d_factor));
}

// ------------------------------------------------------------------

vec3 bilateral_blur(vec2 tex_coord)
{
    const ivec2 size     = textureSize(s_Input, 0);
    const vec2  inv_size = vec2(1.0f / size.x, 1.0f / size.y);

    // Load the center sample depth and normal
    float center_depth  = linear_eye_depth(textureLod(s_GBufferDepth, tex_coord, u_PushConstants.g_buffer_mip).r);
    vec3  center_normal = textureLod(s_GBuffer2, tex_coord, u_PushConstants.g_buffer_mip).rgb;

    vec3  total_color  = textureLod(s_Input, tex_coord, 0).rgb;
    float total_weight = 1.0f;

    for (int i = 0; i < 15; i++)
    {
        // Remap the poisson sample to [-1.0, +1.0] range
        vec2 offset = vec2(g_offsets[i]);

        // Generate sample coordinate
        vec2 sample_tex_coord = tex_coord + (offset * inv_size);

        // Load cross bilateral samples
        vec3  sample_color  = textureLod(s_Input, sample_tex_coord, 0).rgb;
        float sample_depth  = linear_eye_depth(textureLod(s_GBufferDepth, sample_tex_coord, u_PushConstants.g_buffer_mip).r);
        vec3  sample_normal = textureLod(s_GBuffer2, sample_tex_coord, u_PushConstants.g_buffer_mip).rgb;

        // Compute edge-stopping weights
        float weight = depth_edge_stopping_weight(center_depth, sample_depth) * normal_edge_stopping_weight(center_normal, sample_normal);

        // Accumulate samples and weights
        total_color += weight * sample_color;
        total_weight += weight;
    }

    // Divide by total weight
    return total_color / total_weight;
}

// ------------------------------------------------------------------
// MAIN -------------------------------------------------------------
// ------------------------------------------------------------------

void main()
{
    // Query the G-Buffer image size
    const ivec2 size = textureSize(s_GBuffer1, u_PushConstants.g_buffer_mip);

    // Compute current pixel coord
    const ivec2 current_coord = ivec2(gl_GlobalInvocationID.xy);
    const vec2  pixel_center  = vec2(current_coord) + vec2(0.5);
    const vec2  tex_coord     = pixel_center / vec2(size);

    if (current_coord.x >= size.x || current_coord.y >= size.y)
        return;

    // Skip pixel if it belongs to the background
    float depth = textureLod(s_GBufferDepth, tex_coord, u_PushConstants.g_buffer_mip).r;

    if (depth == 1.0f)
    {
        imageStore(i_Output, current_coord, vec4(0.0f));
        return;
    }

    // Blur
    vec3 color = bilateral_blur(tex_coord);

    // Store blurred ao
    imageStore(i_Output, current_coord, vec4(color, 1.0f));
}

// ------------------------------------------------------------------