#version 450

#extension GL_GOOGLE_include_directive : require

#include "random.glsl"

// ------------------------------------------------------------------
// DEFINES ----------------------------------------------------------
// ------------------------------------------------------------------

#define NUM_THREADS_X 32
#define NUM_THREADS_Y 32
#define G_BUFFER_MIP 1
#define DEPTH_FACTOR 0.5

// ------------------------------------------------------------------
// INPUTS -----------------------------------------------------------
// ------------------------------------------------------------------

layout(local_size_x = NUM_THREADS_X, local_size_y = NUM_THREADS_Y, local_size_z = 1) in;

// ------------------------------------------------------------------
// DESCRIPTOR SETS --------------------------------------------------
// ------------------------------------------------------------------

layout(set = 0, binding = 0, r16f) uniform image2D i_Output;

layout(set = 1, binding = 0) uniform sampler2D s_Input;

layout(set = 2, binding = 1) uniform sampler2D s_HistoryLength;

layout(set = 3, binding = 0) uniform sampler2D s_GBuffer1; // RGB: Albedo, A: Roughness
layout(set = 3, binding = 1) uniform sampler2D s_GBuffer2; // RGB: Normal, A: Metallic
layout(set = 3, binding = 2) uniform sampler2D s_GBuffer3; // RG: Motion Vector, BA: -
layout(set = 3, binding = 3) uniform sampler2D s_GBufferDepth;

// ------------------------------------------------------------------------
// PUSH CONSTANTS ---------------------------------------------------------
// ------------------------------------------------------------------------

layout(push_constant) uniform PushConstants
{
    vec4  z_buffer_params;
    int radius;
    uint num_frames;
    uint self_stabilize;
}
u_PushConstants;

// ------------------------------------------------------------------
// SHARED MEMORY ----------------------------------------------------
// ------------------------------------------------------------------

shared float g_cached_ao[NUM_THREADS_X][NUM_THREADS_Y];
shared float g_cached_depth[NUM_THREADS_X][NUM_THREADS_Y];
shared vec3  g_cached_normal[NUM_THREADS_X][NUM_THREADS_Y];

// ------------------------------------------------------------------
// CONSTANTS --------------------------------------------------------
// ------------------------------------------------------------------

#if defined(POISSON_DISK_SAMPLES_16)

const int g_num_poisson_disk_samples = 16;

const vec2 g_poisson_disk_samples[16] = vec2[](
    vec2(0.728111f, 0.346049f),
    vec2(0.0424818f, 0.94351f),
    vec2(0.150121f, 0.079989f),
    vec2(0.6068f, 0.836695f),
    vec2(0.249214f, 0.451796f),
    vec2(0.91702f, 0.0200201f),
    vec2(0.523209f, 0.00186163f),
    vec2(0.964995f, 0.992706f),
    vec2(0.288522f, 0.776635f),
    vec2(0.963744f, 0.632191f),
    vec2(0.531388f, 0.550462f),
    vec2(0.00152593f, 0.622578f),
    vec2(0.384838f, 0.989563f),
    vec2(0.985412f, 0.376415f),
    vec2(0.339549f, 0.175176f),
    vec2(0.745964f, 0.609394f)
);

#else 

const int g_num_poisson_disk_samples = 8;

const vec2 g_poisson_disk_samples[8] = vec2[](
    vec2(0.222022f, 0.498978f),
    vec2(0.756462f, 0.52504f),
    vec2(0.628254f, 0.0187384f),
    vec2(0.495712f, 0.976287f),
    vec2(0.0236824f, 0.0350963f),
    vec2(0.997406f, 0.994263f),
    vec2(0.0237434f, 0.913358f),
    vec2(0.989135f, 0.160924f)
);

#endif

// ------------------------------------------------------------------
// FUNCTIONS --------------------------------------------------------
// ------------------------------------------------------------------

float linear_eye_depth(float z)
{
    return 1.0 / (u_PushConstants.z_buffer_params.z * z + u_PushConstants.z_buffer_params.w);
}

// ------------------------------------------------------------------------

void populate_cache(ivec2 coord)
{
    ivec2 min_cached_coord = ivec2(gl_WorkGroupID.xy) * ivec2(NUM_THREADS_X, NUM_THREADS_Y);
    ivec2 cache_coord      = coord - min_cached_coord;

    g_cached_ao[cache_coord.x][cache_coord.y]     = texelFetch(s_Input, coord, 0).r;
    g_cached_depth[cache_coord.x][cache_coord.y]  = texelFetch(s_GBufferDepth, coord, G_BUFFER_MIP).r;    
    g_cached_normal[cache_coord.x][cache_coord.y] = texelFetch(s_GBuffer2, coord, G_BUFFER_MIP).rgb;

    barrier();
}

// ------------------------------------------------------------------

float load_ao(ivec2 coord)
{
    ivec2 min_cached_coord = ivec2(gl_WorkGroupID.xy) * ivec2(NUM_THREADS_X, NUM_THREADS_Y);
    ivec2 max_cached_coord = ivec2(gl_WorkGroupID.x + 1, gl_WorkGroupID.y + 1) * ivec2(NUM_THREADS_X, NUM_THREADS_Y) - ivec2(1, 1);

    // If requested coord is outside of cache range, sample texture.
    if (any(lessThan(coord, min_cached_coord)) || any(greaterThan(coord, max_cached_coord)))
        return texelFetch(s_Input, coord, 0).r;
    else // Otherwise read from cache.
    {
        ivec2 cache_coord = coord - min_cached_coord;
        return g_cached_ao[cache_coord.x][cache_coord.y];
    }
}

// ------------------------------------------------------------------

float load_depth(ivec2 coord)
{
    ivec2 min_cached_coord = ivec2(gl_WorkGroupID.xy) * ivec2(NUM_THREADS_X, NUM_THREADS_Y);
    ivec2 max_cached_coord = ivec2(gl_WorkGroupID.x + 1, gl_WorkGroupID.y + 1) * ivec2(NUM_THREADS_X, NUM_THREADS_Y) - ivec2(1, 1);

    // If requested coord is outside of cache range, sample texture.
    if (any(lessThan(coord, min_cached_coord)) || any(greaterThan(coord, max_cached_coord)))
        return texelFetch(s_GBufferDepth, coord, G_BUFFER_MIP).r;
    else // Otherwise read from cache.
    {
        ivec2 cache_coord = coord - min_cached_coord;
        return g_cached_depth[cache_coord.x][cache_coord.y];
    }
}

// ------------------------------------------------------------------

vec3 load_normal(ivec2 coord)
{
    ivec2 min_cached_coord = ivec2(gl_WorkGroupID.xy) * ivec2(NUM_THREADS_X, NUM_THREADS_Y);
    ivec2 max_cached_coord = ivec2(gl_WorkGroupID.x + 1, gl_WorkGroupID.y + 1) * ivec2(NUM_THREADS_X, NUM_THREADS_Y) - ivec2(1, 1);

    // If requested coord is outside of cache range, sample texture.
    if (any(lessThan(coord, min_cached_coord)) || any(greaterThan(coord, max_cached_coord)))
        return texelFetch(s_GBuffer2, coord, G_BUFFER_MIP).rgb;
    else // Otherwise read from cache.
    {
        ivec2 cache_coord = coord - min_cached_coord;
        return g_cached_normal[cache_coord.x][cache_coord.y];
    }
}

// ------------------------------------------------------------------------

float normal_edge_stopping_weight(vec3 center_normal, vec3 sample_normal)
{
    return pow(abs(dot(center_normal, sample_normal)), 32);
}

// ------------------------------------------------------------------------

float depth_edge_stopping_weight(float center_lin_depth, float sample_lin_depth)
{
    float depth_diff = abs(center_lin_depth - sample_lin_depth);
    float d_factor   = depth_diff * DEPTH_FACTOR;
    return exp(-(d_factor * d_factor));
}

// ------------------------------------------------------------------

vec2 random_rotation(RNG rng)
{
    float rot = next_float(rng);
    return vec2(sin(rot), cos(rot));
}

// ------------------------------------------------------------------

vec2 rotate_sample(vec2 current_sample, vec2 rot)
{
    return vec2(dot(current_sample, vec2(rot.y, -rot.x)), dot(current_sample, rot));
}

// ------------------------------------------------------------------

float recurrent_blur(ivec2 current_coord)
{
    // Initialize random numbers
    RNG rng = rng_init(current_coord, u_PushConstants.num_frames);

    // Load the center sample depth and normal
    float center_depth  = linear_eye_depth(load_depth(current_coord));     
    vec3  center_normal = load_normal(current_coord);

    float blur_scale = 1.0f;

    if (u_PushConstants.self_stabilize == 1)
    {
        float norm_history_length = max(texelFetch(s_HistoryLength, current_coord, 0).r - 1.0f, 0.0f) / 32.0f;
        float new_count = norm_history_length * 16.0f;
        blur_scale = 1.0f / (1.0f + new_count);    
    }
        
    int radius = int(max(float(u_PushConstants.radius) * blur_scale, 1.0f));

    float total_ao     = load_ao(current_coord);
    float total_weight = 1.0f;
    vec2 rotation = random_rotation(rng);

    for (int i = 0; i < g_num_poisson_disk_samples; i++)
    {
        // Remap the poisson sample to [-1.0, +1.0] range
        vec2 poisson_sample = 2.0f * g_poisson_disk_samples[i] - vec2(1.0f);
        
        // Rotate it
        poisson_sample = rotate_sample(poisson_sample, rotation); 
        
        // Generate sample coordinate
        ivec2 sample_coord  = current_coord + ivec2(poisson_sample * radius);
        
        // Load cross bilateral samples
        float sample_ao     = load_ao(sample_coord);
        float sample_depth  = linear_eye_depth(load_depth(sample_coord)); 
        vec3  sample_normal = load_normal(sample_coord);

        // Compute edge-stopping weights
        float weight = depth_edge_stopping_weight(center_depth, sample_depth) * normal_edge_stopping_weight(center_normal, sample_normal);        
 
        // Accumulate samples and weights
        total_ao += weight * sample_ao;
        total_weight += weight;
    }

    // Divide by total weight
    return total_ao / max(total_weight, 0.0001f);
}

// ------------------------------------------------------------------
// MAIN -------------------------------------------------------------
// ------------------------------------------------------------------

void main()
{
    // Query the G-Buffer image size
    ivec2 size = textureSize(s_GBuffer1, G_BUFFER_MIP);

    // Compute current pixel coord
    ivec2 current_coord = ivec2(gl_GlobalInvocationID.xy);

    // Populate LDS cache
    populate_cache(current_coord);

    // Skip pixel if it belongs to the background
    float depth = load_depth(current_coord);

    if (depth == 1.0f)
    {
        imageStore(i_Output, current_coord, vec4(0.0f));
        return;
    }

    // Blur
    float ao = recurrent_blur(current_coord);

    // Store blurred ao
    imageStore(i_Output, current_coord, vec4(ao));
}

// ------------------------------------------------------------------